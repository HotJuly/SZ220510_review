<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
            this指向
                this是一个关键字,我们无法声明他
                this内部存储的是一个对象,代表着当前函数的调用者是谁
                this与声明位置无关,与调用方式有关

                this很像是形参
                    形参->我们声明的,我们调用函数的时候传入实参,最终传给形参
                    this->浏览器声明的,调用函数的时候自动传入一个对象,最终传给this

            this的常见指向:
                1.普通调用->this是window对象
                    例如:fn();

                    扩展:
                        严格模式下,this是undefined;
                        其实,普通模式下,该写法的this是undefined,会被浏览器强行改成window

                2.隐式调用->this是找到方法的实例对象
                    例如:obj.fn() -> this就是obj

                3.构造调用->this是新创建的实例对象
                    例如:new Fn();

                4.显式调用->this是强行指定的某个对象
                    例如:fn.call(obj)->this就是obj对象
                        call/apply/bind

            特殊的this指向:
                1.Vue
                    生命周期,computed,watch,methods等中,this都是当前组件的实例对象

                2.小程序
                    生命周期,事件回调函数等中,this都是当前页面的实例对象

                3.React
                    class
                        a(){}     =>undefined
                        a=()=>{}    =>this就是当前组件实例对象
                    函数组件
                        this->undefined

                4.定时器
                    this->window

                5.事件回调函数
                    div.onclick=function(){}
                        回调函数中的this就是此处的div,也就是事件源

                6.箭头函数
                    特点:与声明位置有关,与调用方式无关
                    它可以使用外层作用域中的this


                问题1:请问箭头函数是否能被call,apply,bind改变this指向?
                回答:不能

                问题2:请问箭头函数能否被构造调用?
                回答:不能
                    会报错,报错内容是说箭头函数不是一个构造函数

                问题3:请问箭头函数是否拥有自己的原型对象?
                回答:没有
        
        */

      // function a(){
      //     function b(){
      //         console.log(this);
      //     }
      //     b();
      //     return b;
      // }
      // var b = a();
      // b();
      //-----------------------------------

      function fn() {
        console.log(this);
      }
      // fn();

      var obj = {
        fn: fn,
      };
      // obj.fn();

      // 花里胡哨了半天,最终只要关注是从哪个对象身上找到的方法就行
      // 方法前面的一个对象是谁
      //a.b.c.d.e.f.g.h.i()

      // new fn();

      // fn.call(obj)

    //   var obj2 = {
    //     name: "obj2",
    //     fn: () => {
    //       console.log(this);
    //     },
    //   };
    //   obj2.fn.call();

      var fn1 = () => {
        console.log(this);
      };

    //   fn.call(obj)
    // new fn();

    console.dir(fn1)

    // console.dir(fn)
    </script>
  </body>
</html>
