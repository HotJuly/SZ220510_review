# 区别cookie,localStorage,sessionStorage

1. 生命周期
   1. cookie
      1. 如果有设置max-age,数据存储的时间还没有超过max-age,那么数据就会一直存在
      2. 如果没有设置max-age,那他就是**会话级cookie**,那么只要标签页或者浏览器关闭,内部的数据就会丢失
   2. localStorage(持久化存储)
      1. 只要用户不主动删除,那么存储的数据将会永久存在
   3. sessionStorage(会话存储)
      1. 只要标签页或者浏览器关闭,那么存储在内部数据就会丢失
      2. **问题:刷新页面,存储的sessionStorage会不会丢失?**
         1. **刷新不会丢失**
2. 存储位置
   1. cookie
      1. 如果有设置max-age,存储于硬盘中
      2. 如果没有设置max-age,存储于内存中
   2. localStorage(持久化存储)
      1. 存储于硬盘中
   3. sessionStorage(会话存储)
      1. 存储于内存中
3. 存储大小
   1. cookie->4KB
   2. localStorage(持久化存储)->一般是5MB,IE是3012KB
   3. sessionStorage(会话存储)->一般是5MB,IE是3012KB
4. 与服务器之间的关系
   1. cookie(被借用的本地存储)
      1. **服务器创建,浏览器存储**
      2. 服务器返回cookie,浏览器会自动存储
      3. 浏览器发送请求给服务器,会自动携带cookie
      4. 服务器通过在响应头中,添加**set-Cookie**属性,来向浏览器返回cookie数据
      5. 浏览器通过在请求头中,添加**Cookie**属性,来向服务器发送cookie数据
   2. localStorage
      1. 与服务器不熟,没有关系
   3. sessionStorage
      1. 与服务器不熟,没有关系
5. 作用范围
   1. cookie
      1. domain属性
         1. 假设:domain=".baidu.com"
         2. 那么当前这个cookie,就可以在baidu.com衍生出来的子域名中使用
         3. **总结:儿子可以使用父亲的cookie,父亲不能使用儿子**
      2. path属性
         1. 假设:path="/a"
         2. 那么当前这个cookie,就可以在/a衍生出来的子路由中访问
         3. **总结:儿子可以使用父亲的cookie,父亲不能使用儿子**
   2. localStorage
      1. 存储的数据只能在同域名的情况下可以访问
      2. **总结:只要是同域名,即便是不同的标签页,也可以共享(浅拷贝)**
   3. sessionStorage
      1. **不仅要同域名,而且只有当前标签页可见**
      2. **复制当前标签页,会得到最新的标签页,该标签页会有跟旧标签页一样的数据,但是是深拷贝**
6. **面试题:请问如何实现跨标签页通信?**
   1. **前言:需要传递数据的页面简称A页面,需要接收数据的页面简称B页面**
   2. **使用localStorage实现**
      1. **B页面给window对象,绑定事件,事件名称:storage,并传入回调函数**
      2. **A页面通过localStorage.setItem方法,可以向当前域名的localStorage中推送数据**
      3. **由于A页面存储了数据到localStorage,B页面的事件监听就会触发,可以通过event获取到相关数据**
      4. **优点:可以传递多次数据,没有限制**
      5. **缺点:稍微比较麻烦一点**
      6. **使用场景:这种方法是用于两个标签页都是同一个域名才能使用**
   3. **使用URL实现**
      1. **A页面在跳转页面的时候,往B页面的路径中拼接参数**
      2. **当成功跳转到B页面的时候,在location对象中,可以获取到路径中的数据**
      3. **优点:特别方便**
      4. **缺点:想要传递数据,只能在跳转的瞬间进行传递,不适合多次传参**
      5. **使用场景:这种方法可以是用于所有的域名,但是需要对方配合,而且一般只传一次数据**
   4. **使用domain属性实现**
      1. **B页面使用window.open方法,打开A页面的网页,并接受window.open方法的返回值**
         1. **window.open方法的返回值,是新打开的网页的window对象(简称w1)**
      2. **A,B两个页面都将自己的document.domain属性,修改为两者共同的上级域名**
      3. **A页面可以在自己的window对象身上添加数据**
      4. **B页面可以通过流程1中得到的w1对象身上,获取到对应的数据**
      5. **使用场景:这种方法虽然域名可以不相同,但是必须具有相同的上级域名(只适用于本公司内部使用)**