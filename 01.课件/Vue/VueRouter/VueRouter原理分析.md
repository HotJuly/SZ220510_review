# VueRouter

1. 请说说你对VueRouter

   1. 他是一个npm包
   2. 他是Vue的扩展插件库(Vue.use)
   3. 它可以实现单页面应用(SPA)
      1. 问题:什么是单页面应用?
         1. 页面其实就是一个html文件
         2. 整个项目中只有一个html文件,我们可以通过DOM的CRUD方法,对当前的html内容进行操作,从而显示出不同的内容
      2. 问题:请问只是用Vue能否实现单页面应用?
         1. 可以,也就是说VueRouter并不是一个必不可少的插件
      3. 问题:我们是否实现过多页面项目?
         1. 有,例如尚品汇PC端项目或者大疆官网

2. VueRouter给我们提供了什么?

   1. 构造函数
      1. 通过构造函数VueRouter,我们可以创建得到一个路由器对象router
   2. 全局组件
      1. router-view
         1. 用处:用于显示与当前路径匹配的路由组件
         2. **原理:其实就是使用了响应式原理,当路径数据发生变化,router-view组件会自动找到对应的组件进行显示**
      2. router-link
         1. 用处:通过生成a标签,如果用户点击这个a标签就会跳转到指定的路由地址下
         2. **声明式导航的定义:通过标签的形式,引导用户进行跳转,这类操作称为声明式导航**
         3. **原理:其实就是默认生成了一个a标签,给该标签绑定的click事件,在回调函数内部禁用他的默认行为,最终在使用编程式导航跳转**
   3. 公共对象
      1. $router
         1. 这是一个路由器对象,他会提供一些用于操作路由相关的API
         2. push
            1. 可以传入地址,并控制路由器跳转到指定路由地址下
            2. 区别:push会保留上次的历史记录,并跳转到新的路由地址下,也就是说可以返回上一个路由地址
               1. 此处的跳转是伪跳转
            3. **编程式导航的定义:通过js的API,强行控制用户进行路由跳转,这类操作称为编程式导航**
            4. **原理:**
               1. **在hash模式下,push方法中其实是用的是window.location.assign('/#/about'),可以控制当前历史记录栈的跳转,并保留上一个历史记录**
               2. **在history模式下,push方法其实使用了window.history.pushState({},'','/about'),可以控制当前历史记录栈的跳转,并保留上一个历史记录**
         3. replace
            1. 可以传入地址,并控制路由器跳转到指定路由地址下
            2. 区别:replace会保覆盖上次的历史记录,并跳转到新的路由地址下,也就是说可无法返回上一个路由地址
            3. **原理:**
               1. **在hash模式下,replace方法其实使用了window.location.replace('/#/home'),可以控制当前历史记录栈的跳转,并且覆盖上一个历史记录**
               2. **在history模式下,replace方法其实是用了window.history.replaceState({},'','/about'),可以控制当前历史记录栈跳转,并覆盖上一个历史记录**
      2. $route
         1. 这是一个路由对象,他会提供一些当前所在路由相关的信息
         2. 重要属性
            1. fullpath或者path
               1. 用于告知当前所在的路由的路径
            2. query
               1. 他是URL传参的一员
               2. 语法:'/home?key=value'
            3. params
               1. 他是URL传参的一员
               2. 语法:'/home/1333'
               3. 注意:在声明路由对象的时候,需要在path中声明占位符
                  1. '/home/:id'
            4. meta
               1. 他不是URL传参的一员
               2. 该传参方式,需要在声明路由对象的时候,在与path同级的地方书写meta属性
               3. 当用户跳转到对应的路由地址的时候,$route对象中就会接收到对应的meta数据

3. 我们给VueRouter提供了什么?

   1. 配置对象
      1. mode
         1. 用于控制当前VueRouter的路由模式
         2. hash模式
            1. 路径中带有#
            2. **原理:**
               1. **其实是给window对象绑定了一个hashchange事件,用于监视地址栏中hash值的变化**
               2. **通过location.hash即可获取到当前最新的hash值,并将其更新给对应的响应式属性**
            3. 优点:
               1. **兼容性特别好,兼容IE6+**
               2. **上线的时候,不需要做任何特殊的配置**
            4. 缺点:
               1. **丑就是原罪,甲方爸爸看着不爽**
               2. **他的本质其实就是使用锚点功能实现的,所以会导致真正的锚点无法使用**
         3. history模式
            1. 路径中不带有#
            2. **原理:**
               1. **其实是给window对象绑定了一个popstate事件,用于监视地址栏中路径的变化**
                  1. **注意:popstate无法监视到pushState和replaceState方法的调用,他只能监视到浏览器的前进后退功能**
               2. **通过location.pathname即可获取到当前最新的地址值,并将其更新给对应的响应式属性**
            3. 优点:
               1. **颜值就是正义,甲方爸爸看着高兴**
               2. **由于使用的history对象实现的,并不会对锚点功能产生任何的影响**
            4. 缺点:
               1. **兼容性较差,他是HTML5的新特性**
               2. **项目上线的时候,需要后端做一些特殊的配置,否则项目会无法正常运行**
                  1. **问题:前端的/home路由,被浏览器误判为后端接口,结果请求了后端的该接口,导致页面404**
                  2. **流程:**
                     1. **在/home地址下,用户刷新当前浏览器,那么浏览器就会请求当前服务器的/home接口**
                     2. **要求后端将自己没有的接口,统一返回index.html文件(就是项目中唯一的一个html文件)**
                     3. **浏览器接收到html文件之后,会解析当前的内部内容**
                     4. **在html解析过程中,浏览器会发现该网页需要用到服务器上的index.js文件,于是再次请求服务器获取该资源**
                     5. **服务器将index.js文件返回浏览器,那么浏览器会自动执行该js文件中的代码**
                     6. **js代码中的VueRouter代码就会生效,会自动获取当前浏览器的地址,根据地址显示对应的路由组件**
      2. routes属性
         1. 数据类型:routeObj[ ]
         2. routeObj中重要属性
            1. path
               1. 用于声明当前路由的路由地址
            2. component
               1. 如果当前地址栏中的路径匹配某个路由路径,那么就显示该组件

4. 导航守卫

   1. 一共具有7个,三大类

   2. 全局

      1. 全局前置守卫

         1. 在路由跳转之前就会触发

         2. ```javascript
            //是给路由器对象绑定的方法
            router.beforeEach((to, from, next) => {
              // to->想去哪,目的地
              //from->从哪来,出发地
              //next->放行
              //next()->让你过去,你想去哪就去哪
              //next(false)->拒绝放行,从哪来回哪去
              //next('/login')->带你去指定的地方,小黑屋
            })
            ```

            ​

         3. ​

      2. 全局解析守卫

         1. 在跳转之后,解析完路由组件的时候触发

      3. 全局后置守卫

         1. 在跳转到指定路由之后会触发

   3. 路由

      1. 路由独享守卫

      2. ```javascript
         const router = new VueRouter({
           routes: [
             {
               path: '/foo',
               component: Foo,
               beforeEnter: (to, from, next) => {
                 // ...
               }
             }
           ]
         })
         ```

         ​

   4. 组件

      1. 组件进入守卫

      2. 组件更新守卫

      3. 组件离开守卫

      4. ```javascript
         export default {
           data(){
             return{
               msg:123
             }
           },
           mounted(){},
           beforeRouteEnter(to, from, next) {
             // 在渲染该组件的对应路由被 confirm 前调用
             // 不！能！获取组件实例 `this`
             // 因为当守卫执行前，组件实例还没被创建
           },
           beforeRouteUpdate(to, from, next) {
             // 在当前路由改变，但是该组件被复用时调用
             // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
             // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
             // 可以访问组件实例 `this`
           },
           beforeRouteLeave(to, from, next) {
             // 导航离开该组件的对应路由时调用
             // 可以访问组件实例 `this`
           }
         }
         ```

         ​