1.props
	使用场景:父子组件之间通信

	父传子:
		1.父组件给子组件的标签上添加标签属性,属性值是父组件的数据
		2.子组件在自己的配置对象中,添加props用于声明需要接收的标签属性

		总结:父组件传给子组件的是真正的数据

	子传父:
		1.父组件给子组件的标签上添加标签属性,属性值是父组件的函数
			注意:传递的函数,必须是父组件methods中的方法
				因为methods中的方法,this指向当前组件的实例对象

		2.子组件在自己的配置对象中,添加props用于声明需要接收的标签属性

		3.子组件调用父组件传下来的函数,并向内部传入数据
		
		4.父组件的函数被调用,将形参接收到的数据更新到data中即可

		总结:父组件传给子组件的是函数(this指向父组件的函数)

2.provide/inject
	使用场景:祖孙组件之间通信
	祖先组件:
		在祖先组件的配置对象中,添加provide配置属性,属性值可以是对象或者函数
			注意如果想要暴露的数据,是data或者props中的数据,需要将provide写成函数格式
	后代组件:
		在后代组件的配置对象中,添加inject配置属性,属性值是数组

	注意:
		该方法默认情况下,暴露的数据不是响应式的,但是我们可以通过特殊的方法,把暴露的数据变成响应式的
			1.将数据放在data中,先做一波数据劫持,在给provide使用
			2.使用Vue.observable可以将一个普通对象变成响应式对象,最终暴露出去

3.自定义事件

	$on	->它可以给某个组件实例绑定自定义事件
	$once	->他也可以给某个组件实例对象绑定自定义事件,但是只能触发一次
	$emit	->它可以触发某个组件实例对象的某类自定义事件
	$off	->他可以解绑某个组件实例身上的自定义事件

	v-model(双向数据绑定)
		input框使用
			1.会将我们传入的data数据,作为input框的默认值进行展示
    				<input type="text" :value="msg">

			2.当用户修改input中的内容时,会自动修改对应的状态数据的值
    				<input type="text" :value="msg" @input="(event)=>{msg=event.target.value}">

		组件标签使用
			1.通过给子组件添加标签属性的形式,给子组件传递数据(默认标签属性名:value)
    				<HelloWorld :value="msg"/>

			2.父组件给子组件绑定自定义事件,子组件可以触发该自定义事件,来向父组件传递数据(默认事件名:input)
   				<HelloWorld :value="msg" @input="(data)=>msg=data"/>

			注意:默认的属性名称和事件名是可以通过model配置选项实现自定义操作的

		注意:Vue其实是单向数据流,或者说是伪双向

	.sync修饰符
		1.通过给子组件添加标签属性的形式,给子组件传递数据(属性名可以自定义)
    			<HelloWorld :msg="msg"/>

		2.父组件给子组件绑定自定义事件,子组件可以触发该自定义事件,来向父组件传递数据(事件名: update:[属性名])
    			<HelloWorld :msg="msg" @update:msg="(data)=>msg=data"/>

		在Vue3中.v-model和.sync二合一了,表面上还是v-model,内部其实已经是sync

	全局事件总线
		角色
			订阅者->想要接收数据的
			发布者->想要发送数据的

		操作
			1.订阅
			2.发布
			3.解绑(取消订阅)

		约束
			1.订阅者和发布者必须同时存在
			2.订阅必须在发布之前

		流程:
			1.创建一个全局事件总线对象,放于Vue的原型对象上
				Vue.prototype.$bus = new Vue();

			2.在需要接收数据的组件内部,执行$on订阅消息
    				this.$bus.$on('getMsg',(data)=>{
      					console.log('App',data)
    				})

			3.在需要发布数据的组件内部,执行$emit发布消息
    				this.$bus.$emit('getMsg',123)

4.找到对应组件的实例对象
	$parent->可以获取到当前组件的父组件实例对象
	$root->可以获取到当前组件树的根组件实例对象
	$children->可以获取到子组件实例对象组成的数组
		注意点:
			1.并不能保证children数组的顺序
				其实如果没有异步组件的参与,顺序是可以保证和template书写顺序相同的
			2.该数组不是响应式的
				操作该数组中的排列顺序,不会影响到组件在页面上的显示顺序的
	$refs->可以获取到指定的内容
		对原生标签使用->可以获取到该标签的真实DOM
		对组件标签使用->可以获取到该组件的实例对象

		重点:可以让我们具有二次封装UI库的能力

5.$attrs,$listeners
	$attrs->他会收集props没有接收的标签属性以及属性值
		数据类型:对象

		他会将标签属性名作为自己的属性名,标签属性值作为自己的属性值存储

	$listeners->它内部会存储当前组件的所有自定义事件
		数据类型:对象

		他会将自定义事件的名称作为自己的属性名,将事件回调函数作为属性值进行存储

		区分:原生事件和自定义事件
			原生事件:W3C制定的,给原生标签绑定的事件就是原生事件(DOM事件)
				在template给原生DOM,使用@符绑定的事件都是原生事件

			自定义事件:我们制定的,给组件标签绑定的事件就是自定义事件
				在template给组件标签,使用@符绑定的事件都是自定义事件
					扩展:可以给组件的自定义事件后面添加修饰符.native,就可以将该自定义事件变为原生事件
						其实这种写法,也不是给组件绑定原生事件,而是给他的根节点绑定原生事件


		延伸:
			v-bind其实可以接收一个对象,
				他会将该对象的属性名作为标签属性名,属性值作为标签属性值进行展开操作
				注意:v-bind不一定非要配合$attrs使用,只要是个对象就可以

			v-on其实可以接收一个对象,
				他会将对象的属性名作为事件名称,属性值作为事件回调函数进行绑定
				注意:v-on不一定非要配合$listeners使用,只要是个对象就可以


6.插槽
	一共分为三种
	指令v-slot =>#
	插槽是用于向子组件传递结构使用的
		所以子组件标签必须写成成对标签

	默认插槽
		1.父组件将一段插槽结构,通过写在子组件的成对标签中,给子组件传递
		2.子组件想要显示这段结构,就需要在自己的template中,使用slot组件

	具名插槽
		1.父组件将一段插槽结构,通过写在子组件的成对标签中,给子组件传递

		2.父组件在传递插槽结构的使用,需要使用v-slot指令,给当前插槽取名

		3.子组件想要显示这段结构,就需要在自己的template中,使用slot组件

		4.子组件需要在slot组件上,添加标签属性name,用于告知需要显示的具名插槽是哪个

	作用域插槽
		1.父组件将一段插槽结构,通过写在子组件的成对标签中,给子组件传递

		2.父组件在传递插槽结构的使用,需要使用v-slot指令,给当前插槽取名

		3.子组件想要显示这段结构,就需要在自己的template中,使用slot组件

		4.子组件需要在slot组件上,添加标签属性name,用于告知需要显示的具名插槽是哪个

		5.子组件将需要在插槽结构中,显示的数据通过标签属性的形式传给slot组件上
	
		6.父组件在传递插槽结构的时候,可以在插槽名称之后写上="scope",声明一个变量用于接收即将传递过来的数据
			最终在插槽可以直接使用scope中的内容

	插槽中永远只有父传子,没有子传父,作用域插槽会给大家一种错觉,觉得是在子传父,其实没有


7.路由传参

8.Vuex








